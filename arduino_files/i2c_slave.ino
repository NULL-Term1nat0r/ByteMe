#include <Wire.h>
#include <SPI.h>
#include <Adafruit_Sensor.h>
#include "Adafruit_BME680.h"

#define BME_SCK 13
#define BME_MISO 12
#define BME_MOSI 11
#define BME_CS 10

#define SEALEVELPRESSURE_HPA (1013.25)

enum class ModuleState {
  // Startup state; the module is expected to send the initial
  // 20 bytes of the sensor auth descriptor
  NotConnected,

  // The module has sent the first 20 bytes of its auth
  // descriptor; any request in this state is expected to
  // stream the remaining descriptor bytes to the mainboard
  SendAuthChunks,

  // All bytes of the descriptor have been sent; in this state
  // the module is expected to send its current measurement
  // values in 32-byte chunks
  Connected
};

//BME680
typedef struct s_BME680Values {
  float humidity;
  float temperature;
  float air_pressure;
  float air_quality;
}   t_BME680Values;

//Sensor authentification
const static uint8_t g_authDescriptor[] = {
  0x42, 0x79, 0x74, 0x65, 0x4d, 0x65, 0xff, 0x41, 0x75, 0x64, 0x69, 0x00,
  0xea, 0x03, 0x00, 0x00, 0x96, 0x02, 0x00, 0x00, 0x03, 0x0c, 0x30, 0x02,
  0x00, 0xf1, 0x2f, 0xf7, 0x04, 0x04, 0x66, 0x4e, 0x97, 0x8f, 0x2c, 0x1b,
  0x1e, 0x9d, 0x44, 0x4d, 0x04, 0x49, 0x4d, 0x55, 0x53, 0x4f, 0x4d, 0x45,
  0x2d, 0x50, 0x41, 0x52, 0x54, 0x2d, 0x4e, 0x4f, 0x54, 0x68, 0x65, 0x20,
  0x42, 0x4d, 0x45, 0x36, 0x38, 0x30, 0x20, 0x69, 0x73, 0x20, 0x74, 0x68,
  0x65, 0x20, 0x66, 0x69, 0x72, 0x73, 0x74, 0x20, 0x67, 0x61, 0x73, 0x20,
  0x73, 0x65, 0x6e, 0x73, 0x6f, 0x72, 0x20, 0x74, 0x68, 0x61, 0x74, 0x20,
  0x69, 0x6e, 0x74, 0x65, 0x67, 0x72, 0x61, 0x74, 0x65, 0x73, 0x20, 0x68,
  0x69, 0x67, 0x68, 0x2d, 0x6c, 0x69, 0x6e, 0x65, 0x61, 0x72, 0x69, 0x74,
  0x79, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x68, 0x69, 0x67, 0x68, 0x2d, 0x61,
  0x63, 0x63, 0x75, 0x72, 0x61, 0x63, 0x79, 0x20, 0x67, 0x61, 0x73, 0x2c,
  0x20, 0x70, 0x72, 0x65, 0x73, 0x73, 0x75, 0x72, 0x65, 0x2c, 0x20, 0x68,
  0x75, 0x6d, 0x69, 0x64, 0x69, 0x74, 0x79, 0x20, 0x61, 0x6e, 0x64, 0x20,
  0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61, 0x74, 0x75, 0x72, 0x65, 0x20,
  0x73, 0x65, 0x6e, 0x73, 0x6f, 0x72, 0x73, 0x2e, 0x20, 0x49, 0x74, 0x20,
  0x69, 0x73, 0x20, 0x65, 0x73, 0x70, 0x65, 0x63, 0x69, 0x61, 0x6c, 0x6c,
  0x79, 0x20, 0x64, 0x65, 0x76, 0x65, 0x6c, 0x6f, 0x70, 0x65, 0x64, 0x20,
  0x66, 0x6f, 0x72, 0x20, 0x6d, 0x6f, 0x62, 0x69, 0x6c, 0x65, 0x20, 0x61,
  0x70, 0x70, 0x6c, 0x69, 0x63, 0x61, 0x74, 0x69, 0x6f, 0x6e, 0x73, 0x20,
  0x61, 0x6e, 0x64, 0x20, 0x77, 0x65, 0x61, 0x72, 0x61, 0x62, 0x6c, 0x65,
  0x73, 0x20, 0x77, 0x68, 0x65, 0x72, 0x65, 0x20, 0x73, 0x69, 0x7a, 0x65,
  0x20, 0x61, 0x6e, 0x64, 0x20, 0x6c, 0x6f, 0x77, 0x20, 0x70, 0x6f, 0x77,
  0x65, 0x72, 0x20, 0x63, 0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x70, 0x74, 0x69,
  0x6f, 0x6e, 0x20, 0x61, 0x72, 0x65, 0x20, 0x63, 0x72, 0x69, 0x74, 0x69,
  0x63, 0x61, 0x6c, 0x20, 0x72, 0x65, 0x71, 0x75, 0x69, 0x72, 0x65, 0x6d,
  0x65, 0x6e, 0x74, 0x73, 0x2e, 0x20, 0x54, 0x68, 0x65, 0x20, 0x42, 0x4d,
  0x45, 0x36, 0x38, 0x30, 0x20, 0x67, 0x75, 0x61, 0x72, 0x61, 0x6e, 0x74,
  0x65, 0x65, 0x73, 0x20, 0x2d, 0x20, 0x64, 0x65, 0x70, 0x65, 0x6e, 0x64,
  0x69, 0x6e, 0x67, 0x20, 0x6f, 0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x73,
  0x70, 0x65, 0x63, 0x69, 0x66, 0x69, 0x63, 0x20, 0x6f, 0x70, 0x65, 0x72,
  0x61, 0x74, 0x69, 0x6e, 0x67, 0x20, 0x6d, 0x6f, 0x64, 0x65, 0x20, 0x2d,
  0x20, 0x6f, 0x70, 0x74, 0x69, 0x6d, 0x69, 0x7a, 0x65, 0x64, 0x20, 0x63,
  0x6f, 0x6e, 0x73, 0x75, 0x6d, 0x70, 0x74, 0x69, 0x6f, 0x6e, 0x2c, 0x20,
  0x6c, 0x6f, 0x6e, 0x67, 0x2d, 0x74, 0x65, 0x72, 0x6d, 0x20, 0x73, 0x74,
  0x61, 0x62, 0x69, 0x6c, 0x69, 0x74, 0x79, 0x20, 0x61, 0x6e, 0x64, 0x20,
  0x68, 0x69, 0x67, 0x68, 0x20, 0x45, 0x4d, 0x43, 0x20, 0x72, 0x6f, 0x62,
  0x75, 0x73, 0x74, 0x6e, 0x65, 0x73, 0x73, 0x2e, 0x20, 0x49, 0x6e, 0x20,
  0x6f, 0x72, 0x64, 0x65, 0x72, 0x20, 0x74, 0x6f, 0x20, 0x6d, 0x65, 0x61,
  0x73, 0x75, 0x72, 0x65, 0x20, 0x61, 0x69, 0x72, 0x20, 0x71, 0x75, 0x61,
  0x6c, 0x69, 0x74, 0x79, 0x20, 0x66, 0x6f, 0x72, 0x20, 0x70, 0x65, 0x72,
  0x73, 0x6f, 0x6e, 0x61, 0x6c, 0x20, 0x77, 0x65, 0x6c, 0x6c, 0x62, 0x65,
  0x69, 0x6e, 0x67, 0x20, 0x74, 0x68, 0x65, 0x20, 0x67, 0x61, 0x73, 0x20,
  0x73, 0x65, 0x6e, 0x73, 0x6f, 0x72, 0x20, 0x77, 0x69, 0x74, 0x68, 0x69,
  0x6e, 0x20, 0x74, 0x68, 0x65, 0x20, 0x42, 0x4d, 0x45, 0x36, 0x38, 0x30,
  0x20, 0x63, 0x61, 0x6e, 0x20, 0x64, 0x65, 0x74, 0x65, 0x63, 0x74, 0x20,
  0x61, 0x20, 0x62, 0x72, 0x6f, 0x61, 0x64, 0x20, 0x72, 0x61, 0x6e, 0x67,
  0x65, 0x20, 0x6f, 0x66, 0x20, 0x67, 0x61, 0x73, 0x65, 0x73, 0x20, 0x73,
  0x75, 0x63, 0x68, 0x20, 0x61, 0x73, 0x20, 0x76, 0x6f, 0x6c, 0x61, 0x74,
  0x69, 0x6c, 0x65, 0x20, 0x6f, 0x72, 0x67, 0x61, 0x6e, 0x69, 0x63, 0x20,
  0x63, 0x6f, 0x6d, 0x70, 0x6f, 0x75, 0x6e, 0x64, 0x73, 0x20, 0x28, 0x56,
  0x4f, 0x43, 0x29, 0x2e, 0x0b, 0x74, 0x65, 0x6d, 0x70, 0x65, 0x72, 0x61,
  0x74, 0x75, 0x72, 0x65, 0x08, 0x68, 0x75, 0x6d, 0x69, 0x64, 0x69, 0x74,
  0x79, 0x0c, 0x61, 0x69, 0x72, 0x20, 0x70, 0x72, 0x65, 0x73, 0x73, 0x75,
  0x72, 0x65, 0x0b, 0x61, 0x69, 0x72, 0x20, 0x71, 0x75, 0x61, 0x6c, 0x69,
  0x74, 0x79
  // TODO: Populate using the script
};

static ModuleState g_state = ModuleState::Connected;
static uint32_t g_authChunkOffset;


int wantRequest = 0;

//Adafruit_BME680 bme; // I2C
int receivedData = 0; // Variable to store the received data
//Adafruit_BME680 bme(BME_CS); // hardware SPI
Adafruit_BME680 bme(BME_CS, BME_MOSI, BME_MISO, BME_SCK);

void getBME(void)
{
//from BME Loop
  // Tell BME680 to begin measurement.
  unsigned long endTime = bme.beginReading();
  if (endTime == 0) {
    Serial.println(F("Failed to begin reading :("));
    return ;
  }
  //Serial.print("Recieved Data: ");
  //Serial.println(receivedData);

    if (Serial.available() > 0) {
    receivedData = Serial.read(); // Read the received integer
    //Serial.print("Received data: ");
    //Serial.println(receivedData); // Print received data
  } 
  
  //Serial.print(F("Reading started at "));
  //Serial.print(millis());
  //Serial.print(F(" and will finish at "));
  //Serial.println(endTime);
  
  //Serial.println(F("You can do other work during BME680 measurement."));
  //delay(50); // This represents parallel work.
  // There's no need to delay() until millis() >= endTime: bme.endReading()
  // takes care of that. It's okay for parallel work to take longer than
  // BME680's measurement time.

  // Obtain measurement results from BME680. Note that this operation isn't
  // instantaneous even if milli() >= endTime due to I2C/SPI latency.
  
  if (!bme.endReading()) {
    Serial.println(F("Failed to complete reading :("));
    return ;
  }
  /*
  Serial.print(F("Reading completed at "));
  Serial.println(millis());

  Serial.print(F("Temperature = "));
  Serial.print(bme.temperature);
  Serial.println(F(" *C"));

  Serial.print(F("Pressure = "));
  Serial.print(bme.pressure / 100.0);
  Serial.println(F(" hPa"));

  Serial.print(F("Humidity = "));
  Serial.print(bme.humidity);
  Serial.println(F(" %"));

  Serial.print(F("Gas = "));
  Serial.print(bme.gas_resistance / 1000.0);
  Serial.println(F(" KOhms"));

  Serial.print(F("Approx. Altitude = "));
  Serial.print(bme.readAltitude(SEALEVELPRESSURE_HPA));
  Serial.println(F(" m"));

  Serial.print(F("Temperature = "));
  Serial.print(bme.temperature);
  Serial.println(F(" *C"));
  Serial.println();
  delay(2000);
*/
  return;
}


float returnFloat() {
  return 10.2;
}

static void requestHandler() {
  //float value = returnFloat();
  //Wire.write((uint8_t *)&value, sizeof(float));
  wantRequest = 1;
}

void setup() {
  

  //BME680
  //Serial.begin(9600);                       // start serial for output
  //while (!Serial);
  //Serial.println(F("BME680 async test"));
  
  if (!bme.begin()) {
    Serial.println(F("Could not find a valid BME680 sensor, check wiring!"));
    while (1);
  }
 // Set up oversampling and filter initialization
  bme.setTemperatureOversampling(BME680_OS_8X);
  bme.setHumidityOversampling(BME680_OS_2X);
  bme.setPressureOversampling(BME680_OS_4X);
  bme.setIIRFilterSize(BME680_FILTER_SIZE_3);
  bme.setGasHeater(320, 150); // 320*C for 150 ms

  Wire.begin(1);
  Wire.onRequest(requestHandler);
}

void send_BEM_values(void)
{
  t_BME680Values bmeValues;
  getBME();
  bmeValues.humidity = bme.humidity;
  bmeValues.temperature = bme.temperature;
  bmeValues.air_pressure = bme.pressure / 100.0;
  bmeValues.air_quality = bme.gas_resistance / 1000.0;
  Wire.write((uint8_t *)&bmeValues, sizeof(t_BME680Values));
  wantRequest = 0;
}

void loop() {
  while(wantRequest == 1)
  {
   switch (g_state) {
    case ModuleState::NotConnected:
      Wire.write(&g_authDescriptor[0], 20);
      g_state = ModuleState::SendAuthChunks;
      g_authChunkOffset = 20;
      break;
    case ModuleState::SendAuthChunks:
      if (sizeof(g_authDescriptor) - g_authChunkOffset <= 32) {
        Wire.write(&g_authDescriptor[g_authChunkOffset],
          (size_t)(sizeof(g_authDescriptor) - g_authChunkOffset));
        g_state = ModuleState::Connected;
        g_authChunkOffset = sizeof(g_authDescriptor);
      } else {
        Wire.write(&g_authDescriptor[g_authChunkOffset], 32);
        g_authChunkOffset += 32;
      }
      break;
    case ModuleState::Connected:
      // TODO: Send sensor state in 32-byte chunks
      //       The response is latched, the first request
      //       stores the current state which is then streamed out
      send_BEM_values();
      break;
   }
  }
  delay(1000);
}
